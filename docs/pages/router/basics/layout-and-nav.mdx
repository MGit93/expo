---
title: Layout and Navigation
description: Learn how to organize your pages into stack, tabs, and other layouts, and how to navigate to them.
sidebar_title: Layout and Navigation
---

import { FileTree } from '~/ui/components/FileTree';
import { Tabs, Tab } from '~/ui/components/Tabs';

Let's learn about how to construct different navigation layouts, or relationships between pages, and how to navigate from one page to another.

Below we will discuss:
- **Layout**: how your pages are arranged, such as in a stack or tabs
- **Navigation**: how your app moves from one page to another and uses information in the route to load the correct information

## Layout

Each folder within the **app** directory (including **app** itself) can define a layout in the form of a **\_layout.tsx** file inside the folder. This file defines how all the pages within that folder are arranged. This is where you would define a stack navigator, tab navigator, drawer navigator, or any other layout that you want to use for the pages in that folder. The layout file exports a default component that is rendered prior to whatever page you are navigating to within that folder.

Let's look at a few common layout scenarios.

### Root layout

Virtually every app will have a **\_layout.tsx** file directly inside the **app** directory. This is the root layout, and represents the entry point for your navigation. In addition to describing the top-level navigator for your app, this file is where you would put initialization code that may have previously gone inside an **App.js** file, such as loading fonts, interacting with the splash screen, or adding context providers.

Here's an example root layout:

```tsx app/_layout.tsx
import { useFonts } from 'expo-font';
import { Stack } from 'expo-router';
import * as SplashScreen from 'expo-splash-screen';
import { useEffect } from 'react';

SplashScreen.preventAutoHideAsync();

export default function RootLayout() {
  const [loaded] = useFonts({
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
  });

  useEffect(() => {
    if (loaded) {
      SplashScreen.hideAsync();
    }
  }, [loaded]);

  if (!loaded) {
    return null;
  }

  return <Stack />;
}
```

This example keeps the splash screen showing initially, and then renders a stack navigator once the fonts are loaded, which will cause your app to proceed to the initial route.

### Stacks

You can implement a stack navigator in your root layout, as shown above, or in any other layout file inside of a folder. Let's suppose you have a file structure with a stack inside of a folder:

<FileTree
  files={[
    ['app/products/index.tsx'],
    ['app/products/[productId].tsx'],
    ['app/products/\_layout.tsx'],
    ['app/products/accessories/index.tsx'],
  ]}
/>

If you want everything inside of the **products** folder to be arranged in a stack relationship, inside the **\_layout.tsx** file, return a `Stack` component:

```tsx _layout.tsx
import { Stack } from 'expo-router';

export default function StackLayout() {
  return <Stack />;
}
```

When you navigate to `/products`, it will first go to the default route, which is **products/index.tsx**. If you navigate to `/products/123`, then that page will be pushed onto the stack. By default, the stack will render a back button in the header that will pop the current page off the stack, returning the user to the previous page. Even when a page isn't visible, if it is still pushed onto the stack, it is still being rendered.

The `Stack` component implements React Navigation's native stack, and can use the same screen options. However, you do not have to define the pages specifically inside the navigator. The files inside the folder will be automatically treated as eligable routes in the stack. However, if you want to define screen options, you can add a `Stack.Screen` component inside the `Stack` component. The `name` prop should match the route name, but you do not need to supply a `component` prop; Expo Router will map this automatically:

```tsx _layout.tsx
import { Stack } from 'expo-router';

export default function StackLayout() {
  return (
    <Stack>
      <Stack.Screen name="[productId]" options={{ headerShown: false }} />
    </Stack>
  );
}
```

While it is possible nest navigators, be sure to only do so when it is truly needed. In our example, if you wanted to then push **products/accessories/index.tsx** onto the stack, it's not necessary to have an additional **\_layout.tsx** in the **accessories** folder with a `Stack` navigator. That would define another stack inside the first one. It is fine to add folders that only affect the URL, but otherwise use the same navigator as the parent folder.

### Tabs

Much like a stack, you can implement a tab navigator in your layout file, and all the routes directly inside that folder will be treated as tabs. Consider this file structure:

<FileTree
  files={[
    ['app/(tabs)/index.tsx'],
    ['app/(tabs)/feed.tsx'],
    ['app/(tabs)/profile.tsx'],
    ['app/(tabs)/\_layout.tsx'],
  ]}
/>

In the **\_layout.tsx** file, return a `Tab` component:

```tsx _layout.tsx
import { Tab } from 'expo-router';
import MaterialIcons from '@expo/vector-icons/MaterialIcons';

export default function TabLayout() {
  return (
    <Tabs>
      <Tabs.Screen
        name="index"
        options={{
          title: 'Home',
          tabBarIcon: ({ color }) => <MaterialIconse size={28} name="house.fill" color={color} />,
        }}
      />
      <!-- Add more tabs here -->
    </Tabs>
  );
}
```

This will cause the **index.tsx**, **feed.tsx**, and **profile.tsx** files to appear together in the same bottom tabs navigator. This `Tabs` component uses React Navigation's native bottom tabs and supports the same options.

In the case of Tabs, you wll likely want to define the tabs in the navigator, as this will influence the order that tabs appear, the title, and the icon inside the the tab. The index route will be the default selected tab.

### Slot

In some cases, you may want a layout without a navigator. This is helpful for adding a header or footer around the current route, or for displayig a modal over any route inside a folder. In this case, you can use the `Slot` component, which serves as a placeholder for the current child route.

Consider this file structure:

<FileTree
  files={[
    ['app/social/index.tsx'],
    ['app/social/feed.tsx'],
    ['app/social/profile.tsx'],
    ['app/social/\_layout.tsx'],
  ]}
/>

Suppose you want to wrap any route inside the **social** folder with a header and footer, but you want navigating between the pages to simply replace the current page, rather than pushing a new page onto a stack, like what would happen with a `Stack` navigator. In the **\_layout.tsx** file, return a `Slot` component surrounded by your header and footer:

```tsx app/social/_layout.tsx
import { Slot } from 'expo-router';

export default function Layout() {
  return (
    <>
      <Header />
      <Slot />
      <Footer />
    </>
  );
}
```

## Navigating between pages

## Pages

Pages are defined by exporting a React component as the default value from a file in the **app** directory. The file they are exported from must use one of the `.js`, `.jsx`, `.tsx`, `.ts` extensions.

For example, create the **app** directory in your project and then create a file **index.tsx** inside it. Then, add the following snippet:

<Tabs>

<Tab label="Universal">

    Render text on any platform with the `<Text>` component from React Native.

    ```tsx app/index.tsx
    import { Text } from 'react-native';

    export default function Page() {
      return <Text>Top-level page</Text>;
    }
    ```

</Tab>

<Tab label="Web-only">

    Alternatively, you can write web-only React components such as `<div>`, `<p>`, and so on. However, these won't render on native platforms.

    ```tsx app/index.tsx
    export default function Page() {
      return <p>Top-level page</p>;
    }
    ```

</Tab>

</Tabs>

The above example matches the `/` route in the app and the browser. Files named **index** match the parent directory and do not add a path segment. For example, **app/settings/index.tsx** matches `/settings` in the app.

## Platform specific extensions

> **warning** Platform-specific extensions were added in Expo Router `3.5.x`. If you are using an older version of the library, follow instructions from [Platform-specific modules](/router/advanced/platform-specific-modules).

Metro bundler's platform-specific extensions (for example, **.ios.tsx** or **.native.tsx**) are supported in the **app** directory only if a **non-platform version** also exists. This ensures that routes are universal across platforms for deep linking.

Consider the following project structure:

<FileTree
  files={[
    'app/_layout.tsx',
    'app/_layout.web.tsx',
    'app/index.tsx',
    'app/about.tsx',
    'app/about.web.tsx',
  ]}
/>

In the above file structure:

- **\_layout.web.tsx** file is used as a layout on the web and **\_layout.tsx** is used on all other platforms.
- **index.tsx** file is used as the home page for all platforms.
- **about.web.tsx** file is used as the about page for the web, and the **about.tsx** file is used on all other platforms.

> **info** Providing a route file without a platform-specific extension is required to ensure every platform has a default implementation.

## Dynamic routes

Dynamic routes match any unmatched path at a given segment level.

| Route                      | Matched URL          |
| -------------------------- | -------------------- |
| **app/blog/[slug].tsx**    | `/blog/123`          |
| **app/blog/[...rest].tsx** | `/blog/123/settings` |

Routes with higher specificity will be matched before a dynamic route. For example, `/blog/bacon` will match **blog/bacon.tsx** before **blog/[id].tsx**.

Multiple slugs can be matched in a single route by using the rest syntax (`...`). For example, **app/blog/[...id].tsx** matches `/blog/123/settings`.

Dynamic segments are accessible as [route parameters](/router/reference/url-parameters) in the page component.

{/* prettier-ignore */}
```tsx app/blog/[slug].tsx
/* @info Import the <b>useLocalSearchParams</b> React hook */
import { useLocalSearchParams } from 'expo-router';
/* @end */
import { Text } from 'react-native';

export default function Page() {
  /* @info Access the query parameter named <b>slug</b> */
  const { slug } = useLocalSearchParams();
  /* @end */

  return <Text>Blog post: {slug}</Text>;
}
```

## Non-route files

Every file and sub-directory inside the **app** directory is either a `_layout` file or a route in your app. Other files, such as components, hooks, utilities, and so on, cannot be placed in the **app** directory because they are neither screens nor layout files.

<FileTree
  files={[
    'app/(home)/_layout.tsx',
    ['app/(home)/profile.tsx', '/profile'],
    'app/(modal)/_layout.tsx',
    ['app/(modal)/profile.tsx', '/profile'],
  ]}
/>

The above example uses [shared routes](/router/advanced/shared-routes) for the `/profile` route inside two sub-directories. If you want to create a non-route file (for example, **ProfileImageComponent.tsx**), finding the correct sub-directory to place this file creates a dilemma since there are two route directories. This is "why" Expo Router does not allow non-route files to exist with route files inside the **app** directory because it leads to an unstructured project.

### Recommended structure

Expo Router recommends sorting components and hooks by "feature" and routes by "navigation pattern". While the two concepts can overlap, there are enough differences to structure them differently. Additionally, routes will inevitably change. However, components generally stay within the same feature set. Keeping routes separate will simplify your refactors.

<FileTree
  files={[
    'app/sign-in',
    'app/sign-out',
    'app/profile',
    'app/tasks',
    'components/authentication',
    'components/tasks/overview',
    'components/profile/[user]',
  ]}
/>

In the above example, both `/sign-in` and `/sign-out` are authentication routes and share components from the **components/authentication** file. However, the `/profile/[user]` route is complex and renders components that belong to the authentication, profile, and task features. If you place your components within the **app** directory, it's not obvious where these components belong. By separating components from routes, you create an organized hierarchy with the philosophy that a route is a collection of reusable components, and a component does not belong to an individual route.

Another project optimization is to utilize [path aliases](/guides/typescript/#path-aliases-optional). They keep your routes project structure agnostic, as imports within your routes no longer depend on the **app** directory structure. This avoids large `import` statement changes when adding new directories (such as new groups) and prevents lengthy `import` paths.

### Reserved keywords

Expo Router is built on top of [React Navigation](https://reactnavigation.org/), which imposes certain restrictions on the naming of screen parameters. As a result, the following words cannot be used as dynamic route parameters in Expo Router:

- `screen`
- `params`
- `key`
